// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: class.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addUserToClass = `-- name: AddUserToClass :exec

INSERT INTO
    "user_class" (user_id, class_id)
VALUES ($1, $2) ON CONFLICT (user_id, class_id)
DO NOTHING
`

type AddUserToClassParams struct {
	UserID  string
	ClassID uuid.UUID
}

func (q *Queries) AddUserToClass(ctx context.Context, arg AddUserToClassParams) error {
	_, err := q.db.ExecContext(ctx, addUserToClass, arg.UserID, arg.ClassID)
	return err
}

const createClass = `-- name: CreateClass :one

INSERT INTO
    "class" (
        name,
        learn_id,
        start_at,
        end_at
    )
VALUES ($1, $2, $3, $4) RETURNING id, name, learn_id, start_at, end_at, created_at, updated_at
`

type CreateClassParams struct {
	Name    string
	LearnID int32
	StartAt time.Time
	EndAt   time.Time
}

func (q *Queries) CreateClass(ctx context.Context, arg CreateClassParams) (*Class, error) {
	row := q.db.QueryRowContext(ctx, createClass,
		arg.Name,
		arg.LearnID,
		arg.StartAt,
		arg.EndAt,
	)
	var i Class
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LearnID,
		&i.StartAt,
		&i.EndAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteClass = `-- name: DeleteClass :exec

DELETE FROM "class" WHERE id = $1
`

func (q *Queries) DeleteClass(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteClass, id)
	return err
}

const findClass = `-- name: FindClass :one

SELECT
    cl.id, cl.name, cl.learn_id, cl.start_at, cl.end_at, cl.created_at, cl.updated_at,
    c.language,
    c.topic
FROM "class" cl
    JOIN "learn" c ON cl.learn_id = c.id
WHERE cl.id = $1
ORDER BY cl.created_at ASC
`

type FindClassRow struct {
	ID        uuid.UUID
	Name      string
	LearnID   int32
	StartAt   time.Time
	EndAt     time.Time
	CreatedAt time.Time
	UpdatedAt time.Time
	Language  string
	Topic     string
}

func (q *Queries) FindClass(ctx context.Context, id uuid.UUID) (*FindClassRow, error) {
	row := q.db.QueryRowContext(ctx, findClass, id)
	var i FindClassRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LearnID,
		&i.StartAt,
		&i.EndAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Language,
		&i.Topic,
	)
	return &i, err
}

const listClasses = `-- name: ListClasses :many

SELECT
    cl.id, cl.name, cl.learn_id, cl.start_at, cl.end_at, cl.created_at, cl.updated_at,
    c.language,
    c.topic
FROM "class" cl
    JOIN "learn" c ON cl.learn_id = c.id
ORDER BY cl.created_at ASC
`

type ListClassesRow struct {
	ID        uuid.UUID
	Name      string
	LearnID   int32
	StartAt   time.Time
	EndAt     time.Time
	CreatedAt time.Time
	UpdatedAt time.Time
	Language  string
	Topic     string
}

func (q *Queries) ListClasses(ctx context.Context) ([]*ListClassesRow, error) {
	rows, err := q.db.QueryContext(ctx, listClasses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListClassesRow
	for rows.Next() {
		var i ListClassesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LearnID,
			&i.StartAt,
			&i.EndAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Language,
			&i.Topic,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClassesOfUser = `-- name: ListClassesOfUser :many

SELECT
    cl.id, cl.name, cl.learn_id, cl.start_at, cl.end_at, cl.created_at, cl.updated_at,
    c.language,
    c.topic
FROM "class" cl
    JOIN "user_class" uc ON cl.id = uc.class_id
    JOIN "learn" c ON cl.learn_id = c.id
WHERE uc.user_id = $1
ORDER BY uc.created_at ASC
`

type ListClassesOfUserRow struct {
	ID        uuid.UUID
	Name      string
	LearnID   int32
	StartAt   time.Time
	EndAt     time.Time
	CreatedAt time.Time
	UpdatedAt time.Time
	Language  string
	Topic     string
}

func (q *Queries) ListClassesOfUser(ctx context.Context, userID string) ([]*ListClassesOfUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listClassesOfUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListClassesOfUserRow
	for rows.Next() {
		var i ListClassesOfUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LearnID,
			&i.StartAt,
			&i.EndAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Language,
			&i.Topic,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersInClass = `-- name: ListUsersInClass :many

SELECT
    u.id,
    u.first_name,
    u.last_name,
    u.role,
    u.prefered_language,
    u.avatar_file_path,
    u.avatar_url,
    u.created_at
FROM "user" u
    JOIN "user_class" uc ON u.id = uc.user_id
WHERE uc.class_id = $1
`

type ListUsersInClassRow struct {
	ID               string
	FirstName        string
	LastName         string
	Role             Role
	PreferedLanguage string
	AvatarFilePath   string
	AvatarUrl        string
	CreatedAt        time.Time
}

func (q *Queries) ListUsersInClass(ctx context.Context, classID uuid.UUID) ([]*ListUsersInClassRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersInClass, classID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersInClassRow
	for rows.Next() {
		var i ListUsersInClassRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Role,
			&i.PreferedLanguage,
			&i.AvatarFilePath,
			&i.AvatarUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromClass = `-- name: RemoveUserFromClass :exec

DELETE FROM "user_class" WHERE user_id = $1 AND class_id = $2
`

type RemoveUserFromClassParams struct {
	UserID  string
	ClassID uuid.UUID
}

func (q *Queries) RemoveUserFromClass(ctx context.Context, arg RemoveUserFromClassParams) error {
	_, err := q.db.ExecContext(ctx, removeUserFromClass, arg.UserID, arg.ClassID)
	return err
}
