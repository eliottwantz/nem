// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: teacher.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createTeacher = `-- name: CreateTeacher :one
INSERT INTO "teacher" (id, bio, hour_rate)
VALUES ($1, $2, $3)
RETURNING id, bio, hour_rate, top_agent
`

type CreateTeacherParams struct {
	ID       uuid.UUID
	Bio      string
	HourRate int32
}

func (q *Queries) CreateTeacher(ctx context.Context, arg CreateTeacherParams) (*Teacher, error) {
	row := q.db.QueryRowContext(ctx, createTeacher, arg.ID, arg.Bio, arg.HourRate)
	var i Teacher
	err := row.Scan(
		&i.ID,
		&i.Bio,
		&i.HourRate,
		&i.TopAgent,
	)
	return &i, err
}

const findTeacherByID = `-- name: FindTeacherByID :one
SELECT "user".id, "user".email, "user".first_name, "user".last_name, "user".role, "user".prefered_language, "user".avatar_file_path, "user".avatar_url, "user".stripe_customer_id, "user".created_at, "user".updated_at,
    "teacher"."bio",
    "teacher"."hour_rate",
    "teacher"."top_agent",
    "teacher_ratings"."rating",
    ARRAY(
        SELECT ROW(
                "language"."language",
                "spoken_language"."proficiency"
            )
        FROM "teacher_spoken_language"
            JOIN "spoken_language" ON "spoken_language"."id" = "teacher_spoken_language"."spoken_language_id"
            JOIN "language" ON "language"."id" = "spoken_language"."language_id"
        WHERE "teacher_spoken_language"."teacher_id" = "teacher"."id"
    ) AS "spoken_languages",
    ARRAY(
        SELECT "topics"."topic"
        FROM teacher_topic
            JOIN "topics" ON "topics"."id" = teacher_topic."topic_id"
        WHERE teacher_topic."teacher_id" = "teacher"."id"
    ) AS "topics_taught"
FROM "user"
    JOIN "teacher" ON "teacher"."id" = "user"."id"
    LEFT JOIN "teacher_ratings" ON "teacher_ratings"."teacher_id" = "teacher"."id"
WHERE teacher.id = $1
`

type FindTeacherByIDRow struct {
	ID               uuid.UUID
	Email            string
	FirstName        string
	LastName         string
	Role             Role
	PreferedLanguage string
	AvatarFilePath   string
	AvatarUrl        string
	StripeCustomerID sql.NullString
	CreatedAt        time.Time
	UpdatedAt        time.Time
	Bio              string
	HourRate         int32
	TopAgent         bool
	Rating           sql.NullString
	SpokenLanguages  interface{}
	TopicsTaught     interface{}
}

func (q *Queries) FindTeacherByID(ctx context.Context, id uuid.UUID) (*FindTeacherByIDRow, error) {
	row := q.db.QueryRowContext(ctx, findTeacherByID, id)
	var i FindTeacherByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Role,
		&i.PreferedLanguage,
		&i.AvatarFilePath,
		&i.AvatarUrl,
		&i.StripeCustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
		&i.HourRate,
		&i.TopAgent,
		&i.Rating,
		&i.SpokenLanguages,
		&i.TopicsTaught,
	)
	return &i, err
}

const listLanguagesOfAllTeachers = `-- name: ListLanguagesOfAllTeachers :many
SELECT DISTINCT language.language
FROM teacher_spoken_language
    JOIN "spoken_language" ON "spoken_language"."id" = "teacher_spoken_language"."spoken_language_id"
    JOIN "language" ON "language"."id" = "spoken_language"."language_id"
`

func (q *Queries) ListLanguagesOfAllTeachers(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listLanguagesOfAllTeachers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var language string
		if err := rows.Scan(&language); err != nil {
			return nil, err
		}
		items = append(items, language)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeachers = `-- name: ListTeachers :many
SELECT ROW_NUMBER() OVER () as "row_id",
    id, email, first_name, last_name, role, prefered_language, avatar_file_path, avatar_url, stripe_customer_id, created_at, updated_at, bio, hour_rate, top_agent, rating, spoken_languages, topics_taught
FROM (
        SELECT DISTINCT u.id, u.email, u.first_name, u.last_name, u.role, u.prefered_language, u.avatar_file_path, u.avatar_url, u.stripe_customer_id, u.created_at, u.updated_at,
            t.bio,
            t.hour_rate,
            t.top_agent,
            COALESCE(tr.rating, 0) as rating,
            ARRAY(
                SELECT ROW(
                        "language"."language",
                        "spoken_language"."proficiency"
                    )
                FROM "teacher_spoken_language"
                    JOIN "spoken_language" ON "spoken_language"."id" = "teacher_spoken_language"."spoken_language_id"
                    JOIN "language" ON "language"."id" = "spoken_language"."language_id"
                WHERE "teacher_spoken_language"."teacher_id" = t."id"
            ) AS "spoken_languages",
            ARRAY(
                SELECT "topics"."topic"
                FROM teacher_topic
                    JOIN "topics" ON "topics"."id" = teacher_topic."topic_id"
                WHERE teacher_topic."teacher_id" = t."id"
            ) AS "topics_taught"
        FROM "user" u
            JOIN teacher t ON u.id = t.id
            JOIN teacher_topic tt ON t.id = tt.teacher_id
            JOIN topics tp ON tt.topic_id = tp.id
            JOIN teacher_spoken_language tsl ON t.id = tsl.teacher_id
            JOIN spoken_language sl ON tsl.spoken_language_id = sl.id
            JOIN "language" ON sl.language_id = "language".id
            LEFT JOIN teacher_ratings tr ON t.id = tr.teacher_id
        WHERE t.hour_rate <= $1
            AND (
                t.top_agent = $2
                OR t.top_agent = $3
            )
            AND (
                tp.topic = $4
                OR tp.topic LIKE $5
            )
            AND (
                language.language = $6
                OR language.language LIKE $7
            )
            AND COALESCE(tr.rating, 0) >= $8
    ) "inner"
`

type ListTeachersParams struct {
	HourRate   int32
	TopAgent   bool
	TopAgent_2 bool
	Topic      string
	Topic_2    string
	Language   string
	Language_2 string
	Rating     string
}

type ListTeachersRow struct {
	RowID            int64
	ID               uuid.UUID
	Email            string
	FirstName        string
	LastName         string
	Role             Role
	PreferedLanguage string
	AvatarFilePath   string
	AvatarUrl        string
	StripeCustomerID sql.NullString
	CreatedAt        time.Time
	UpdatedAt        time.Time
	Bio              string
	HourRate         int32
	TopAgent         bool
	Rating           string
	SpokenLanguages  interface{}
	TopicsTaught     interface{}
}

func (q *Queries) ListTeachers(ctx context.Context, arg ListTeachersParams) ([]*ListTeachersRow, error) {
	rows, err := q.db.QueryContext(ctx, listTeachers,
		arg.HourRate,
		arg.TopAgent,
		arg.TopAgent_2,
		arg.Topic,
		arg.Topic_2,
		arg.Language,
		arg.Language_2,
		arg.Rating,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListTeachersRow
	for rows.Next() {
		var i ListTeachersRow
		if err := rows.Scan(
			&i.RowID,
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Role,
			&i.PreferedLanguage,
			&i.AvatarFilePath,
			&i.AvatarUrl,
			&i.StripeCustomerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Bio,
			&i.HourRate,
			&i.TopAgent,
			&i.Rating,
			&i.SpokenLanguages,
			&i.TopicsTaught,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeachersOfStudent = `-- name: ListTeachersOfStudent :many
SELECT "user".id, "user".email, "user".first_name, "user".last_name, "user".role, "user".prefered_language, "user".avatar_file_path, "user".avatar_url, "user".stripe_customer_id, "user".created_at, "user".updated_at,
    "teacher"."bio",
    "teacher"."hour_rate",
    "teacher"."top_agent",
    "teacher_ratings"."rating",
    ARRAY(
        SELECT ROW(
                "language"."language",
                "spoken_language"."proficiency"
            )
        FROM "teacher_spoken_language"
            JOIN "spoken_language" ON "spoken_language"."id" = "teacher_spoken_language"."spoken_language_id"
            JOIN "language" ON "language"."id" = "spoken_language"."language_id"
        WHERE "teacher_spoken_language"."teacher_id" = "teacher"."id"
    ) AS "spoken_languages",
    ARRAY(
        SELECT "topics"."topic"
        FROM teacher_topic
            JOIN "topics" ON "topics"."id" = teacher_topic."topic_id"
        WHERE teacher_topic."teacher_id" = "teacher"."id"
    ) AS "topics_taught"
FROM "user"
    JOIN "teacher" ON "teacher"."id" = "user"."id"
    JOIN "students_of_teacher" ON "students_of_teacher"."teacher_id" = "teacher"."id"
    LEFT JOIN "teacher_ratings" ON "teacher_ratings"."teacher_id" = "teacher"."id"
WHERE "students_of_teacher"."student_id" = $1
`

type ListTeachersOfStudentRow struct {
	ID               uuid.UUID
	Email            string
	FirstName        string
	LastName         string
	Role             Role
	PreferedLanguage string
	AvatarFilePath   string
	AvatarUrl        string
	StripeCustomerID sql.NullString
	CreatedAt        time.Time
	UpdatedAt        time.Time
	Bio              string
	HourRate         int32
	TopAgent         bool
	Rating           sql.NullString
	SpokenLanguages  interface{}
	TopicsTaught     interface{}
}

func (q *Queries) ListTeachersOfStudent(ctx context.Context, studentID uuid.UUID) ([]*ListTeachersOfStudentRow, error) {
	rows, err := q.db.QueryContext(ctx, listTeachersOfStudent, studentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListTeachersOfStudentRow
	for rows.Next() {
		var i ListTeachersOfStudentRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Role,
			&i.PreferedLanguage,
			&i.AvatarFilePath,
			&i.AvatarUrl,
			&i.StripeCustomerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Bio,
			&i.HourRate,
			&i.TopAgent,
			&i.Rating,
			&i.SpokenLanguages,
			&i.TopicsTaught,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopicsTaughtByAllTeachers = `-- name: ListTopicsTaughtByAllTeachers :many
SELECT DISTINCT topics.id, topics.topic
FROM teacher_topic
    JOIN "topics" ON "topics"."id" = teacher_topic."topic_id"
`

func (q *Queries) ListTopicsTaughtByAllTeachers(ctx context.Context) ([]*Topic, error) {
	rows, err := q.db.QueryContext(ctx, listTopicsTaughtByAllTeachers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(&i.ID, &i.Topic); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const teachersCount = `-- name: TeachersCount :one
SELECT COUNT(*)
FROM "user"
    JOIN "teacher" ON "user"."id" = "teacher"."id"
`

func (q *Queries) TeachersCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, teachersCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}
