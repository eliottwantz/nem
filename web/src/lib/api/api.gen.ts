/* eslint-disable */
// nem v0.1.0 5f0ade8c9e48f5fb52be356829ff6966cdcfce78
// --
// Code generated by webrpc-gen@v0.12.1 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=main.ridl -target=typescript -client -out=./web/src/lib/api/api.gen.ts

// WebRPC description and code-gen version
export const WebRPCVersion = "v1"

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "v0.1.0"

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "5f0ade8c9e48f5fb52be356829ff6966cdcfce78"

//
// Types
//


export interface User {
  id: string
  email: string
  firstName: string
  lastName: string
  role: string
  preferedLanguage: string
  avatarFilePath: string
  avatarUrl: string
  createdAt: string
  updatedAt: string
}

export interface Teacher {
  id: string
  email: string
  firstName: string
  lastName: string
  role: string
  preferedLanguage: string
  avatarFilePath: string
  avatarUrl: string
  bio: string
  hourRate: number
  topAgent: boolean
  spokenLanguages: Array<SpokenLanguage>
  topicsTaught: Array<string>
  createdAt: string
  updatedAt: string
}

export interface SpokenLanguage {
  language: string
  proficiency: string
}

export interface CreateStudentRequest {
  firstName: string
  lastName: string
  email: string
  role: string
  preferedLanguage: string
}

export interface CreateTeacherRequest {
  firstName: string
  lastName: string
  email: string
  role: string
  preferedLanguage: string
  bio: string
  hourRate: number
  spokenLanguages: Array<CreateTeacherRequestSpokenLanguage>
}

export interface CreateTeacherRequestSpokenLanguage {
  language: string
  proficiency: string
}

export interface Topic {
  id: number
  topic: string
}

export interface Class {
  id: string
  teacherId: string
  isPrivate: boolean
  name: string
  hasStarted: boolean
  language: string
  topic: string
  startAt: string
  endAt: string
  createdAt: string
}

export interface ClassDetails {
  class: Class
  users: Array<User>
  teacher: Teacher
}

export interface Message {
  text: string
  classId: string
}

export interface MessageResponse {
  id: string
  text: string
  createdAt: string
  updatedAt: string
  classId: string
  user: User
}

export interface TimesRequest {
  startAt: string
  endAt: string
}

export interface AddAvailabilityRequest {
  times: Array<TimesRequest>
  startAt: string
  endAt: string
}

export interface EditAvailabilityRequest {
  id: string
  times: Array<TimesRequest>
  startAt: string
  endAt: string
}

export interface TimeSlot {
  id: string
  teacherId: string
  startAt: string
  endAt: string
}

export interface CreateClassRequest {
  name: string
  isPrivate: boolean
  language: string
  topic: string
  timeSlotId: string
}

export interface ListTeachersFilters {
  language: string
  topic: string
  topAgent: boolean
  priceMax: number
  ratingMin: number
  ratingMax: number
  cursor: string
}

export interface UserServiceAPI {
  get(headers?: object, signal?: AbortSignal): Promise<GetReturn>
  findUserByID(args: FindUserByIDArgs, headers?: object, signal?: AbortSignal): Promise<FindUserByIDReturn>
  listTeachers(args: ListTeachersArgs, headers?: object, signal?: AbortSignal): Promise<ListTeachersReturn>
  createStudent(args: CreateStudentArgs, headers?: object, signal?: AbortSignal): Promise<CreateStudentReturn>
  createTeacher(args: CreateTeacherArgs, headers?: object, signal?: AbortSignal): Promise<CreateTeacherReturn>
  updatePreferedLanguage(args: UpdatePreferedLanguageArgs, headers?: object, signal?: AbortSignal): Promise<UpdatePreferedLanguageReturn>
  updateAvatar(args: UpdateAvatarArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAvatarReturn>
  deleteAvatar(headers?: object, signal?: AbortSignal): Promise<DeleteAvatarReturn>
  delete(headers?: object, signal?: AbortSignal): Promise<DeleteReturn>
}

export interface GetArgs {
}

export interface GetReturn {
  user: User  
}
export interface FindUserByIDArgs {
  id: string
}

export interface FindUserByIDReturn {
  user: User  
}
export interface ListTeachersArgs {
  filters: ListTeachersFilters
}

export interface ListTeachersReturn {
  teachers: Array<Teacher>  
}
export interface CreateStudentArgs {
  req: CreateStudentRequest
}

export interface CreateStudentReturn {  
}
export interface CreateTeacherArgs {
  req: CreateTeacherRequest
}

export interface CreateTeacherReturn {  
}
export interface UpdatePreferedLanguageArgs {
  lang: string
}

export interface UpdatePreferedLanguageReturn {  
}
export interface UpdateAvatarArgs {
  path: string
  url: string
}

export interface UpdateAvatarReturn {  
}
export interface DeleteAvatarArgs {
}

export interface DeleteAvatarReturn {  
}
export interface DeleteArgs {
}

export interface DeleteReturn {  
}

export interface StudentServiceAPI {
  listClasses(headers?: object, signal?: AbortSignal): Promise<ListClassesReturn>
  listTeachersOfStudent(headers?: object, signal?: AbortSignal): Promise<ListTeachersOfStudentReturn>
  joinClass(args: JoinClassArgs, headers?: object, signal?: AbortSignal): Promise<JoinClassReturn>
  leaveClass(args: LeaveClassArgs, headers?: object, signal?: AbortSignal): Promise<LeaveClassReturn>
}

export interface ListClassesArgs {
}

export interface ListClassesReturn {
  classes: Array<Class>  
}
export interface ListTeachersOfStudentArgs {
}

export interface ListTeachersOfStudentReturn {
  teachers: Array<Teacher>  
}
export interface JoinClassArgs {
  classId: string
}

export interface JoinClassReturn {  
}
export interface LeaveClassArgs {
  classId: string
}

export interface LeaveClassReturn {  
}

export interface TeacherServiceAPI {
  findTeacherByID(args: FindTeacherByIDArgs, headers?: object, signal?: AbortSignal): Promise<FindTeacherByIDReturn>
  listClasses(args: ListClassesArgs, headers?: object, signal?: AbortSignal): Promise<ListClassesReturn>
  listStudents(args: ListStudentsArgs, headers?: object, signal?: AbortSignal): Promise<ListStudentsReturn>
  listAvailabilities(args: ListAvailabilitiesArgs, headers?: object, signal?: AbortSignal): Promise<ListAvailabilitiesReturn>
  teach(args: TeachArgs, headers?: object, signal?: AbortSignal): Promise<TeachReturn>
  stopTeachingTopics(args: StopTeachingTopicsArgs, headers?: object, signal?: AbortSignal): Promise<StopTeachingTopicsReturn>
  addAvailability(args: AddAvailabilityArgs, headers?: object, signal?: AbortSignal): Promise<AddAvailabilityReturn>
  updateAvailability(args: UpdateAvailabilityArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAvailabilityReturn>
  deleteAvailability(args: DeleteAvailabilityArgs, headers?: object, signal?: AbortSignal): Promise<DeleteAvailabilityReturn>
  startClass(args: StartClassArgs, headers?: object, signal?: AbortSignal): Promise<StartClassReturn>
  endClass(args: EndClassArgs, headers?: object, signal?: AbortSignal): Promise<EndClassReturn>
  cancelClass(args: CancelClassArgs, headers?: object, signal?: AbortSignal): Promise<CancelClassReturn>
}

export interface FindTeacherByIDArgs {
  id: string
}

export interface FindTeacherByIDReturn {
  teacher: Teacher  
}
export interface ListClassesArgs {
  teacherId: string
}

export interface ListClassesReturn {
  classes: Array<Class>  
}
export interface ListStudentsArgs {
  teacherId: string
}

export interface ListStudentsReturn {
  students: Array<User>  
}
export interface ListAvailabilitiesArgs {
  teacherId: string
}

export interface ListAvailabilitiesReturn {
  timeSlots: Array<TimeSlot>  
}
export interface TeachArgs {
  topic: string
}

export interface TeachReturn {  
}
export interface StopTeachingTopicsArgs {
  topics: Array<string>
}

export interface StopTeachingTopicsReturn {  
}
export interface AddAvailabilityArgs {
  req: AddAvailabilityRequest
}

export interface AddAvailabilityReturn {
  timeSlots: Array<TimeSlot>  
}
export interface UpdateAvailabilityArgs {
  req: EditAvailabilityRequest
}

export interface UpdateAvailabilityReturn {
  timeSlots: Array<TimeSlot>  
}
export interface DeleteAvailabilityArgs {
  id: string
}

export interface DeleteAvailabilityReturn {  
}
export interface StartClassArgs {
  classId: string
}

export interface StartClassReturn {  
}
export interface EndClassArgs {
  classId: string
}

export interface EndClassReturn {  
}
export interface CancelClassArgs {
  classId: string
}

export interface CancelClassReturn {
  usersInClass: Array<User>
  teacher: User  
}

export interface ClassServiceAPI {
  listLanguages(headers?: object, signal?: AbortSignal): Promise<ListLanguagesReturn>
  listTopics(headers?: object, signal?: AbortSignal): Promise<ListTopicsReturn>
  showClassDetails(args: ShowClassDetailsArgs, headers?: object, signal?: AbortSignal): Promise<ShowClassDetailsReturn>
  getJoinToken(args: GetJoinTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetJoinTokenReturn>
  createOrJoinClass(args: CreateOrJoinClassArgs, headers?: object, signal?: AbortSignal): Promise<CreateOrJoinClassReturn>
}

export interface ListLanguagesArgs {
}

export interface ListLanguagesReturn {
  languages: Array<string>  
}
export interface ListTopicsArgs {
}

export interface ListTopicsReturn {
  topics: Array<string>  
}
export interface ShowClassDetailsArgs {
  classId: string
}

export interface ShowClassDetailsReturn {
  classDetails: ClassDetails  
}
export interface GetJoinTokenArgs {
  roomId: string
}

export interface GetJoinTokenReturn {
  token: string  
}
export interface CreateOrJoinClassArgs {
  req: CreateClassRequest
}

export interface CreateOrJoinClassReturn {
  class: Class  
}

export interface MessageServiceAPI {
  sendMessage(args: SendMessageArgs, headers?: object, signal?: AbortSignal): Promise<SendMessageReturn>
}

export interface SendMessageArgs {
  message: Message
}

export interface SendMessageReturn {  
}


  
//
// Client
//
export class UserServiceAPI implements UserServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/UserServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  get = (headers?: object, signal?: AbortSignal): Promise<GetReturn> => {
    return this.fetch(
      this.url('Get'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          user: <User>(_data.user),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  findUserByID = (args: FindUserByIDArgs, headers?: object, signal?: AbortSignal): Promise<FindUserByIDReturn> => {
    return this.fetch(
      this.url('FindUserByID'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          user: <User>(_data.user),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listTeachers = (args: ListTeachersArgs, headers?: object, signal?: AbortSignal): Promise<ListTeachersReturn> => {
    return this.fetch(
      this.url('ListTeachers'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          teachers: <Array<Teacher>>(_data.teachers),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  createStudent = (args: CreateStudentArgs, headers?: object, signal?: AbortSignal): Promise<CreateStudentReturn> => {
    return this.fetch(
      this.url('CreateStudent'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  createTeacher = (args: CreateTeacherArgs, headers?: object, signal?: AbortSignal): Promise<CreateTeacherReturn> => {
    return this.fetch(
      this.url('CreateTeacher'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  updatePreferedLanguage = (args: UpdatePreferedLanguageArgs, headers?: object, signal?: AbortSignal): Promise<UpdatePreferedLanguageReturn> => {
    return this.fetch(
      this.url('UpdatePreferedLanguage'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  updateAvatar = (args: UpdateAvatarArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAvatarReturn> => {
    return this.fetch(
      this.url('UpdateAvatar'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  deleteAvatar = (headers?: object, signal?: AbortSignal): Promise<DeleteAvatarReturn> => {
    return this.fetch(
      this.url('DeleteAvatar'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  delete = (headers?: object, signal?: AbortSignal): Promise<DeleteReturn> => {
    return this.fetch(
      this.url('Delete'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class StudentServiceAPI implements StudentServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/StudentServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  listClasses = (headers?: object, signal?: AbortSignal): Promise<ListClassesReturn> => {
    return this.fetch(
      this.url('ListClasses'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          classes: <Array<Class>>(_data.classes),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listTeachersOfStudent = (headers?: object, signal?: AbortSignal): Promise<ListTeachersOfStudentReturn> => {
    return this.fetch(
      this.url('ListTeachersOfStudent'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          teachers: <Array<Teacher>>(_data.teachers),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  joinClass = (args: JoinClassArgs, headers?: object, signal?: AbortSignal): Promise<JoinClassReturn> => {
    return this.fetch(
      this.url('JoinClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  leaveClass = (args: LeaveClassArgs, headers?: object, signal?: AbortSignal): Promise<LeaveClassReturn> => {
    return this.fetch(
      this.url('LeaveClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class TeacherServiceAPI implements TeacherServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/TeacherServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  findTeacherByID = (args: FindTeacherByIDArgs, headers?: object, signal?: AbortSignal): Promise<FindTeacherByIDReturn> => {
    return this.fetch(
      this.url('FindTeacherByID'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          teacher: <Teacher>(_data.teacher),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listClasses = (args: ListClassesArgs, headers?: object, signal?: AbortSignal): Promise<ListClassesReturn> => {
    return this.fetch(
      this.url('ListClasses'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          classes: <Array<Class>>(_data.classes),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listStudents = (args: ListStudentsArgs, headers?: object, signal?: AbortSignal): Promise<ListStudentsReturn> => {
    return this.fetch(
      this.url('ListStudents'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          students: <Array<User>>(_data.students),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listAvailabilities = (args: ListAvailabilitiesArgs, headers?: object, signal?: AbortSignal): Promise<ListAvailabilitiesReturn> => {
    return this.fetch(
      this.url('ListAvailabilities'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          timeSlots: <Array<TimeSlot>>(_data.timeSlots),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  teach = (args: TeachArgs, headers?: object, signal?: AbortSignal): Promise<TeachReturn> => {
    return this.fetch(
      this.url('Teach'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  stopTeachingTopics = (args: StopTeachingTopicsArgs, headers?: object, signal?: AbortSignal): Promise<StopTeachingTopicsReturn> => {
    return this.fetch(
      this.url('StopTeachingTopics'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  addAvailability = (args: AddAvailabilityArgs, headers?: object, signal?: AbortSignal): Promise<AddAvailabilityReturn> => {
    return this.fetch(
      this.url('AddAvailability'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          timeSlots: <Array<TimeSlot>>(_data.timeSlots),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  updateAvailability = (args: UpdateAvailabilityArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAvailabilityReturn> => {
    return this.fetch(
      this.url('UpdateAvailability'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          timeSlots: <Array<TimeSlot>>(_data.timeSlots),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  deleteAvailability = (args: DeleteAvailabilityArgs, headers?: object, signal?: AbortSignal): Promise<DeleteAvailabilityReturn> => {
    return this.fetch(
      this.url('DeleteAvailability'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  startClass = (args: StartClassArgs, headers?: object, signal?: AbortSignal): Promise<StartClassReturn> => {
    return this.fetch(
      this.url('StartClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  endClass = (args: EndClassArgs, headers?: object, signal?: AbortSignal): Promise<EndClassReturn> => {
    return this.fetch(
      this.url('EndClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  cancelClass = (args: CancelClassArgs, headers?: object, signal?: AbortSignal): Promise<CancelClassReturn> => {
    return this.fetch(
      this.url('CancelClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          usersInClass: <Array<User>>(_data.usersInClass),
          teacher: <User>(_data.teacher),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class ClassServiceAPI implements ClassServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/ClassServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  listLanguages = (headers?: object, signal?: AbortSignal): Promise<ListLanguagesReturn> => {
    return this.fetch(
      this.url('ListLanguages'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          languages: <Array<string>>(_data.languages),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listTopics = (headers?: object, signal?: AbortSignal): Promise<ListTopicsReturn> => {
    return this.fetch(
      this.url('ListTopics'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          topics: <Array<string>>(_data.topics),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  showClassDetails = (args: ShowClassDetailsArgs, headers?: object, signal?: AbortSignal): Promise<ShowClassDetailsReturn> => {
    return this.fetch(
      this.url('ShowClassDetails'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          classDetails: <ClassDetails>(_data.classDetails),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  getJoinToken = (args: GetJoinTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetJoinTokenReturn> => {
    return this.fetch(
      this.url('GetJoinToken'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          token: <string>(_data.token),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  createOrJoinClass = (args: CreateOrJoinClassArgs, headers?: object, signal?: AbortSignal): Promise<CreateOrJoinClassReturn> => {
    return this.fetch(
      this.url('CreateOrJoinClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          class: <Class>(_data.class),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class MessageServiceAPI implements MessageServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/MessageServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  sendMessage = (args: SendMessageArgs, headers?: object, signal?: AbortSignal): Promise<SendMessageReturn> => {
    return this.fetch(
      this.url('SendMessage'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

  const createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {}),
    signal
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(error) {
      let message = ''
      if (error instanceof Error)  {
        message = error.message
      }
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text}`},
      )
    }
    if (!res.ok) {
      const code: number = (typeof data.code === 'number') ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

//
// Errors
//

export class WebrpcError extends Error {
  name: string
  code: number
  message: string
  status: number
  cause?: string

  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
  msg: string

  constructor(name: string, code: number, message: string, status: number, cause?: string) {
    super(message)
    this.name = name || 'WebrpcError'
    this.code = typeof code === 'number' ? code : 0
    this.message = message || `endpoint error ${this.code}`
    this.msg = this.message
    this.status = typeof status === 'number' ? status : 0
    this.cause = cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)
  }
}

// Webrpc errors

export class WebrpcEndpointError extends WebrpcError {
  constructor(
    name: string = 'WebrpcEndpoint',
    code: number = 0,
    message: string = 'endpoint error',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcRequestFailed',
    code: number = -1,
    message: string = 'request failed',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadRoute',
    code: number = -2,
    message: string = 'bad route',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadMethod',
    code: number = -3,
    message: string = 'bad method',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadRequest',
    code: number = -4,
    message: string = 'bad request',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadResponse',
    code: number = -5,
    message: string = 'bad response',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(
    name: string = 'WebrpcServerPanic',
    code: number = -6,
    message: string = 'server panic',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(
    name: string = 'WebrpcInternalError',
    code: number = -7,
    message: string = 'internal error',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}


// Schema errors

export class UnauthorizedError extends WebrpcError {
  constructor(
    name: string = 'Unauthorized',
    code: number = 401,
    message: string = 'Unauthorized access',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(
    name: string = 'PermissionDenied',
    code: number = 403,
    message: string = 'Permission denied',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class UserAlreadyRegisteredError extends WebrpcError {
  constructor(
    name: string = 'UserAlreadyRegistered',
    code: number = 1,
    message: string = 'User already registered',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UserAlreadyRegisteredError.prototype)
  }
}


export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  UserAlreadyRegistered = 'UserAlreadyRegistered',
}

const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [401]: UnauthorizedError,
  [403]: PermissionDeniedError,
  [1]: UserAlreadyRegisteredError,
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
