/* eslint-disable */
// nem v0.1.0 054a7f063c83b2f6ad0cdaaac5bfa55e708506cf
// --
// Code generated by webrpc-gen@v0.12.1 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=main.ridl -target=typescript -client -out=./web/src/lib/api/api.gen.ts

// WebRPC description and code-gen version
export const WebRPCVersion = "v1"

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "v0.1.0"

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "054a7f063c83b2f6ad0cdaaac5bfa55e708506cf"

//
// Types
//


export interface AdminCreateClassRequest {
  userIDs: Array<string>
  name: string
  learnId: number
  start_at: string
  end_at: string
}

export interface User {
  id: string
  firstName: string
  lastName: string
  role: string
  preferedLanguage: string
  avatarFilePath: string
  avatarUrl: string
  createdAt: string
}

export interface CreateUserRequest {
  firstName: string
  lastName: string
  role: string
  preferedLanguage: string
}

export interface CreateUserResponse {
  user: User
}

export interface Learn {
  id: number
  language: string
  topic: string
}

export interface Teach {
  id: number
  language: string
  topic: string
}

export interface Class {
  id: string
  name: string
  language: string
  topic: string
  startAt: string
  endAt: string
  createdAt: string
  updatedAt: string
}

export interface ClassDetails {
  class: Class
  users: Array<User>
}

export interface Message {
  text: string
  classId: string
}

export interface MessageResponse {
  id: string
  text: string
  createdAt: string
  updatedAt: string
  classId: string
  user: User
}

export interface AdminServiceAPI {
  adminListUsers(headers?: object, signal?: AbortSignal): Promise<AdminListUsersReturn>
  adminListClasses(headers?: object, signal?: AbortSignal): Promise<AdminListClassesReturn>
  adminSetRole(args: AdminSetRoleArgs, headers?: object, signal?: AbortSignal): Promise<AdminSetRoleReturn>
  adminCreateClass(args: AdminCreateClassArgs, headers?: object, signal?: AbortSignal): Promise<AdminCreateClassReturn>
}

export interface AdminListUsersArgs {
}

export interface AdminListUsersReturn {
  users: Array<User>  
}
export interface AdminListClassesArgs {
}

export interface AdminListClassesReturn {
  classes: Array<Class>  
}
export interface AdminSetRoleArgs {
  uID: string
  role: string
}

export interface AdminSetRoleReturn {  
}
export interface AdminCreateClassArgs {
  req: AdminCreateClassRequest
}

export interface AdminCreateClassReturn {
  class: Class  
}

export interface UserServiceAPI {
  get(headers?: object, signal?: AbortSignal): Promise<GetReturn>
  create(args: CreateArgs, headers?: object, signal?: AbortSignal): Promise<CreateReturn>
  chooseRole(args: ChooseRoleArgs, headers?: object, signal?: AbortSignal): Promise<ChooseRoleReturn>
  updatePreferedLanguage(args: UpdatePreferedLanguageArgs, headers?: object, signal?: AbortSignal): Promise<UpdatePreferedLanguageReturn>
  updateAvatar(args: UpdateAvatarArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAvatarReturn>
  deleteAvatar(headers?: object, signal?: AbortSignal): Promise<DeleteAvatarReturn>
  delete(headers?: object, signal?: AbortSignal): Promise<DeleteReturn>
}

export interface GetArgs {
}

export interface GetReturn {
  user: User  
}
export interface CreateArgs {
  req: CreateUserRequest
}

export interface CreateReturn {
  user: User  
}
export interface ChooseRoleArgs {
  role: string
}

export interface ChooseRoleReturn {  
}
export interface UpdatePreferedLanguageArgs {
  lang: string
}

export interface UpdatePreferedLanguageReturn {  
}
export interface UpdateAvatarArgs {
  path: string
  url: string
}

export interface UpdateAvatarReturn {  
}
export interface DeleteAvatarArgs {
}

export interface DeleteAvatarReturn {  
}
export interface DeleteArgs {
}

export interface DeleteReturn {  
}

export interface StudentServiceAPI {
  listLearns(headers?: object, signal?: AbortSignal): Promise<ListLearnsReturn>
  learn(args: LearnArgs, headers?: object, signal?: AbortSignal): Promise<LearnReturn>
  listClasses(headers?: object, signal?: AbortSignal): Promise<ListClassesReturn>
  joinClass(args: JoinClassArgs, headers?: object, signal?: AbortSignal): Promise<JoinClassReturn>
  leaveClass(args: LeaveClassArgs, headers?: object, signal?: AbortSignal): Promise<LeaveClassReturn>
}

export interface ListLearnsArgs {
}

export interface ListLearnsReturn {
  learns: Array<Learn>  
}
export interface LearnArgs {
  language: string
  topic: string
}

export interface LearnReturn {
  learn: Learn  
}
export interface ListClassesArgs {
}

export interface ListClassesReturn {
  classes: Array<Class>  
}
export interface JoinClassArgs {
  classId: string
}

export interface JoinClassReturn {  
}
export interface LeaveClassArgs {
  classId: string
}

export interface LeaveClassReturn {  
}

export interface TeacherServiceAPI {
  listTeaches(headers?: object, signal?: AbortSignal): Promise<ListTeachesReturn>
  teach(args: TeachArgs, headers?: object, signal?: AbortSignal): Promise<TeachReturn>
  listClasses(headers?: object, signal?: AbortSignal): Promise<ListClassesReturn>
  startClass(args: StartClassArgs, headers?: object, signal?: AbortSignal): Promise<StartClassReturn>
  endClass(args: EndClassArgs, headers?: object, signal?: AbortSignal): Promise<EndClassReturn>
}

export interface ListTeachesArgs {
}

export interface ListTeachesReturn {
  teaches: Array<Teach>  
}
export interface TeachArgs {
  language: string
  topic: string
}

export interface TeachReturn {
  teach: Teach  
}
export interface ListClassesArgs {
}

export interface ListClassesReturn {
  classes: Array<Class>  
}
export interface StartClassArgs {
  classId: string
}

export interface StartClassReturn {  
}
export interface EndClassArgs {
  classId: string
}

export interface EndClassReturn {  
}

export interface ClassServiceAPI {
  listLanguages(headers?: object, signal?: AbortSignal): Promise<ListLanguagesReturn>
  listTopics(headers?: object, signal?: AbortSignal): Promise<ListTopicsReturn>
  listAvailableLearns(headers?: object, signal?: AbortSignal): Promise<ListAvailableLearnsReturn>
  showClassDetails(args: ShowClassDetailsArgs, headers?: object, signal?: AbortSignal): Promise<ShowClassDetailsReturn>
  getJoinToken(args: GetJoinTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetJoinTokenReturn>
}

export interface ListLanguagesArgs {
}

export interface ListLanguagesReturn {
  languages: Array<string>  
}
export interface ListTopicsArgs {
}

export interface ListTopicsReturn {
  topics: Array<string>  
}
export interface ListAvailableLearnsArgs {
}

export interface ListAvailableLearnsReturn {
  learns: Array<Learn>  
}
export interface ShowClassDetailsArgs {
  classId: string
}

export interface ShowClassDetailsReturn {
  class: ClassDetails  
}
export interface GetJoinTokenArgs {
  roomId: string
}

export interface GetJoinTokenReturn {
  token: string  
}

export interface MessageServiceAPI {
  sendMessage(args: SendMessageArgs, headers?: object, signal?: AbortSignal): Promise<SendMessageReturn>
}

export interface SendMessageArgs {
  message: Message
}

export interface SendMessageReturn {  
}


  
//
// Client
//
export class AdminServiceAPI implements AdminServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/AdminServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  adminListUsers = (headers?: object, signal?: AbortSignal): Promise<AdminListUsersReturn> => {
    return this.fetch(
      this.url('AdminListUsers'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          users: <Array<User>>(_data.users),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  adminListClasses = (headers?: object, signal?: AbortSignal): Promise<AdminListClassesReturn> => {
    return this.fetch(
      this.url('AdminListClasses'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          classes: <Array<Class>>(_data.classes),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  adminSetRole = (args: AdminSetRoleArgs, headers?: object, signal?: AbortSignal): Promise<AdminSetRoleReturn> => {
    return this.fetch(
      this.url('AdminSetRole'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  adminCreateClass = (args: AdminCreateClassArgs, headers?: object, signal?: AbortSignal): Promise<AdminCreateClassReturn> => {
    return this.fetch(
      this.url('AdminCreateClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          class: <Class>(_data.class),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class UserServiceAPI implements UserServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/UserServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  get = (headers?: object, signal?: AbortSignal): Promise<GetReturn> => {
    return this.fetch(
      this.url('Get'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          user: <User>(_data.user),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  create = (args: CreateArgs, headers?: object, signal?: AbortSignal): Promise<CreateReturn> => {
    return this.fetch(
      this.url('Create'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          user: <User>(_data.user),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  chooseRole = (args: ChooseRoleArgs, headers?: object, signal?: AbortSignal): Promise<ChooseRoleReturn> => {
    return this.fetch(
      this.url('ChooseRole'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  updatePreferedLanguage = (args: UpdatePreferedLanguageArgs, headers?: object, signal?: AbortSignal): Promise<UpdatePreferedLanguageReturn> => {
    return this.fetch(
      this.url('UpdatePreferedLanguage'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  updateAvatar = (args: UpdateAvatarArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAvatarReturn> => {
    return this.fetch(
      this.url('UpdateAvatar'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  deleteAvatar = (headers?: object, signal?: AbortSignal): Promise<DeleteAvatarReturn> => {
    return this.fetch(
      this.url('DeleteAvatar'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  delete = (headers?: object, signal?: AbortSignal): Promise<DeleteReturn> => {
    return this.fetch(
      this.url('Delete'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class StudentServiceAPI implements StudentServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/StudentServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  listLearns = (headers?: object, signal?: AbortSignal): Promise<ListLearnsReturn> => {
    return this.fetch(
      this.url('ListLearns'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          learns: <Array<Learn>>(_data.learns),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  learn = (args: LearnArgs, headers?: object, signal?: AbortSignal): Promise<LearnReturn> => {
    return this.fetch(
      this.url('Learn'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          learn: <Learn>(_data.learn),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listClasses = (headers?: object, signal?: AbortSignal): Promise<ListClassesReturn> => {
    return this.fetch(
      this.url('ListClasses'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          classes: <Array<Class>>(_data.classes),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  joinClass = (args: JoinClassArgs, headers?: object, signal?: AbortSignal): Promise<JoinClassReturn> => {
    return this.fetch(
      this.url('JoinClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  leaveClass = (args: LeaveClassArgs, headers?: object, signal?: AbortSignal): Promise<LeaveClassReturn> => {
    return this.fetch(
      this.url('LeaveClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class TeacherServiceAPI implements TeacherServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/TeacherServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  listTeaches = (headers?: object, signal?: AbortSignal): Promise<ListTeachesReturn> => {
    return this.fetch(
      this.url('ListTeaches'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          teaches: <Array<Teach>>(_data.teaches),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  teach = (args: TeachArgs, headers?: object, signal?: AbortSignal): Promise<TeachReturn> => {
    return this.fetch(
      this.url('Teach'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          teach: <Teach>(_data.teach),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listClasses = (headers?: object, signal?: AbortSignal): Promise<ListClassesReturn> => {
    return this.fetch(
      this.url('ListClasses'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          classes: <Array<Class>>(_data.classes),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  startClass = (args: StartClassArgs, headers?: object, signal?: AbortSignal): Promise<StartClassReturn> => {
    return this.fetch(
      this.url('StartClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  endClass = (args: EndClassArgs, headers?: object, signal?: AbortSignal): Promise<EndClassReturn> => {
    return this.fetch(
      this.url('EndClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class ClassServiceAPI implements ClassServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/ClassServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  listLanguages = (headers?: object, signal?: AbortSignal): Promise<ListLanguagesReturn> => {
    return this.fetch(
      this.url('ListLanguages'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          languages: <Array<string>>(_data.languages),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listTopics = (headers?: object, signal?: AbortSignal): Promise<ListTopicsReturn> => {
    return this.fetch(
      this.url('ListTopics'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          topics: <Array<string>>(_data.topics),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listAvailableLearns = (headers?: object, signal?: AbortSignal): Promise<ListAvailableLearnsReturn> => {
    return this.fetch(
      this.url('ListAvailableLearns'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          learns: <Array<Learn>>(_data.learns),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  showClassDetails = (args: ShowClassDetailsArgs, headers?: object, signal?: AbortSignal): Promise<ShowClassDetailsReturn> => {
    return this.fetch(
      this.url('ShowClassDetails'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          class: <ClassDetails>(_data.class),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  getJoinToken = (args: GetJoinTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetJoinTokenReturn> => {
    return this.fetch(
      this.url('GetJoinToken'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          token: <string>(_data.token),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class MessageServiceAPI implements MessageServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/MessageServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  sendMessage = (args: SendMessageArgs, headers?: object, signal?: AbortSignal): Promise<SendMessageReturn> => {
    return this.fetch(
      this.url('SendMessage'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

  const createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {}),
    signal
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(error) {
      let message = ''
      if (error instanceof Error)  {
        message = error.message
      }
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text}`},
      )
    }
    if (!res.ok) {
      const code: number = (typeof data.code === 'number') ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

//
// Errors
//

export class WebrpcError extends Error {
  name: string
  code: number
  message: string
  status: number
  cause?: string

  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
  msg: string

  constructor(name: string, code: number, message: string, status: number, cause?: string) {
    super(message)
    this.name = name || 'WebrpcError'
    this.code = typeof code === 'number' ? code : 0
    this.message = message || `endpoint error ${this.code}`
    this.msg = this.message
    this.status = typeof status === 'number' ? status : 0
    this.cause = cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)
  }
}

// Webrpc errors

export class WebrpcEndpointError extends WebrpcError {
  constructor(
    name: string = 'WebrpcEndpoint',
    code: number = 0,
    message: string = 'endpoint error',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcRequestFailed',
    code: number = -1,
    message: string = 'request failed',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadRoute',
    code: number = -2,
    message: string = 'bad route',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadMethod',
    code: number = -3,
    message: string = 'bad method',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadRequest',
    code: number = -4,
    message: string = 'bad request',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadResponse',
    code: number = -5,
    message: string = 'bad response',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(
    name: string = 'WebrpcServerPanic',
    code: number = -6,
    message: string = 'server panic',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(
    name: string = 'WebrpcInternalError',
    code: number = -7,
    message: string = 'internal error',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}


// Schema errors

export class UnauthorizedError extends WebrpcError {
  constructor(
    name: string = 'Unauthorized',
    code: number = 401,
    message: string = 'Unauthorized access',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(
    name: string = 'PermissionDenied',
    code: number = 403,
    message: string = 'Permission denied',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class UserAlreadyRegisteredError extends WebrpcError {
  constructor(
    name: string = 'UserAlreadyRegistered',
    code: number = 1,
    message: string = 'User already registered',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UserAlreadyRegisteredError.prototype)
  }
}


export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  UserAlreadyRegistered = 'UserAlreadyRegistered',
}

const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [401]: UnauthorizedError,
  [403]: PermissionDeniedError,
  [1]: UserAlreadyRegisteredError,
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
