/* eslint-disable */
// nem v0.1.0 e4156003d5aa09d4474ef294082c7a4ed6fd655c
// --
// Code generated by webrpc-gen@v0.13.1 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=main.ridl -target=typescript -client -out=./web/src/lib/api/api.gen.ts

// WebRPC description and code-gen version
export const WebRPCVersion = "v1"

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "v0.1.0"

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "e4156003d5aa09d4474ef294082c7a4ed6fd655c"

//
// Types
//


export interface User {
  id: string
  email: string
  firstName: string
  lastName: string
  role: string
  preferedLanguage: string
  avatarFilePath: string
  avatarUrl: string
  stripeCustomerId: string
  createdAt: string
  updatedAt: string
}

export interface Teacher {
  id: string
  email: string
  firstName: string
  lastName: string
  role: string
  preferedLanguage: string
  avatarFilePath: string
  avatarUrl: string
  bio: string
  hourRate: number
  topAgent: boolean
  rating: number
  spokenLanguages: Array<SpokenLanguage>
  topicsTaught: Array<string>
  stripeCustomerId: string
  createdAt: string
  updatedAt: string
}

export interface ListTeacher {
  rowId: number
  id: string
  email: string
  firstName: string
  lastName: string
  role: string
  preferedLanguage: string
  avatarFilePath: string
  avatarUrl: string
  bio: string
  hourRate: number
  topAgent: boolean
  rating: number
  spokenLanguages: Array<SpokenLanguage>
  topicsTaught: Array<string>
  stripeCustomerId: string
  createdAt: string
  updatedAt: string
}

export interface SpokenLanguage {
  language: string
  proficiency: string
}

export interface CreateStudentRequest {
  firstName: string
  lastName: string
  email: string
  role: string
  preferedLanguage: string
}

export interface CreateTeacherRequest {
  firstName: string
  lastName: string
  email: string
  role: string
  preferedLanguage: string
  bio: string
  hourRate: number
  spokenLanguages: Array<CreateTeacherRequestSpokenLanguage>
  topicsTaught: Array<string>
}

export interface CreateTeacherRequestSpokenLanguage {
  language: string
  proficiency: string
}

export interface Topic {
  id: number
  topic: string
}

export interface Class {
  id: string
  teacherId: string
  isPrivate: boolean
  isTrial: boolean
  name: string
  hasStarted: boolean
  language: string
  topic: string
  startAt: string
  endAt: string
  createdAt: string
}

export interface ListClass {
  id: string
  teacherId: string
  teacherFirstName: string
  teacherLastName: string
  teacherAvatarUrl: string
  teacherAvatarFilePath: string
  isPrivate: boolean
  isTrial: boolean
  name: string
  hasStarted: boolean
  language: string
  topic: string
  startAt: string
  endAt: string
  createdAt: string
}

export interface ClassDetails {
  class: Class
  users: Array<User>
  teacher: Teacher
}

export interface SentMessage {
  text: string
  conversationId: number
}

export interface Message {
  id: number
  text: string
  sentAt: string
  updatedAt: string
  conversationId: number
  sender: User
}

export interface TimesRequest {
  startAt: string
  endAt: string
}

export interface AddAvailabilityRequest {
  times: Array<TimesRequest>
  startAt: string
  endAt: string
}

export interface EditAvailabilityRequest {
  id: string
  times: Array<TimesRequest>
  startAt: string
  endAt: string
}

export interface TimeSlot {
  id: string
  teacherId: string
  startAt: string
  endAt: string
}

export interface CreateClassRequest {
  userId: string
  name: string
  isPrivate: boolean
  isTrial: boolean
  language: string
  topic: string
  timeSlotId: string
}

export interface ListTeachersFilters {
  language: string
  topic: string
  topAgent: boolean
  priceMax: number
  ratingMin: number
  cursor: number
}

export interface Conversation {
  id: number
  isClassChat: boolean
  users: Array<User>
  lastSent: string
  createdAt: string
}

export interface Subscription {
  id: string
  name: string
  hours: number
}

export interface PublicServiceAPI {
  createOrJoinClass(args: CreateOrJoinClassArgs, headers?: object, signal?: AbortSignal): Promise<CreateOrJoinClassReturn>
  addHoursToHoursBank(args: AddHoursToHoursBankArgs, headers?: object, signal?: AbortSignal): Promise<AddHoursToHoursBankReturn>
}

export interface CreateOrJoinClassArgs {
  req: CreateClassRequest
}

export interface CreateOrJoinClassReturn {
  class: Class  
}
export interface AddHoursToHoursBankArgs {
  studentId: string
  teacherId: string
  hours: number
}

export interface AddHoursToHoursBankReturn {  
}

export interface UserServiceAPI {
  get(headers?: object, signal?: AbortSignal): Promise<GetReturn>
  findUserByID(args: FindUserByIDArgs, headers?: object, signal?: AbortSignal): Promise<FindUserByIDReturn>
  listTeachers(args: ListTeachersArgs, headers?: object, signal?: AbortSignal): Promise<ListTeachersReturn>
  teachersCount(headers?: object, signal?: AbortSignal): Promise<TeachersCountReturn>
  listTopicsTaught(headers?: object, signal?: AbortSignal): Promise<ListTopicsTaughtReturn>
  listLanguagesTaught(headers?: object, signal?: AbortSignal): Promise<ListLanguagesTaughtReturn>
  createStudent(args: CreateStudentArgs, headers?: object, signal?: AbortSignal): Promise<CreateStudentReturn>
  createTeacher(args: CreateTeacherArgs, headers?: object, signal?: AbortSignal): Promise<CreateTeacherReturn>
  updatePreferedLanguage(args: UpdatePreferedLanguageArgs, headers?: object, signal?: AbortSignal): Promise<UpdatePreferedLanguageReturn>
  updateAvatar(args: UpdateAvatarArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAvatarReturn>
  deleteAvatar(headers?: object, signal?: AbortSignal): Promise<DeleteAvatarReturn>
  delete(headers?: object, signal?: AbortSignal): Promise<DeleteReturn>
  addStripeCustomerId(args: AddStripeCustomerIdArgs, headers?: object, signal?: AbortSignal): Promise<AddStripeCustomerIdReturn>
}

export interface GetArgs {
}

export interface GetReturn {
  user: User  
}
export interface FindUserByIDArgs {
  id: string
}

export interface FindUserByIDReturn {
  user: User  
}
export interface ListTeachersArgs {
  filters: ListTeachersFilters
}

export interface ListTeachersReturn {
  teachers: Array<ListTeacher>  
}
export interface TeachersCountArgs {
}

export interface TeachersCountReturn {
  count: number  
}
export interface ListTopicsTaughtArgs {
}

export interface ListTopicsTaughtReturn {
  topics: Array<Topic>  
}
export interface ListLanguagesTaughtArgs {
}

export interface ListLanguagesTaughtReturn {
  languages: Array<string>  
}
export interface CreateStudentArgs {
  req: CreateStudentRequest
}

export interface CreateStudentReturn {  
}
export interface CreateTeacherArgs {
  req: CreateTeacherRequest
}

export interface CreateTeacherReturn {  
}
export interface UpdatePreferedLanguageArgs {
  lang: string
}

export interface UpdatePreferedLanguageReturn {  
}
export interface UpdateAvatarArgs {
  path: string
  url: string
}

export interface UpdateAvatarReturn {  
}
export interface DeleteAvatarArgs {
}

export interface DeleteAvatarReturn {  
}
export interface DeleteArgs {
}

export interface DeleteReturn {  
}
export interface AddStripeCustomerIdArgs {
  stripeId: string
}

export interface AddStripeCustomerIdReturn {  
}

export interface StudentServiceAPI {
  listClasses(headers?: object, signal?: AbortSignal): Promise<ListClassesReturn>
  listTeachersOfStudent(headers?: object, signal?: AbortSignal): Promise<ListTeachersOfStudentReturn>
  getHoursBankForTeacher(args: GetHoursBankForTeacherArgs, headers?: object, signal?: AbortSignal): Promise<GetHoursBankForTeacherReturn>
  listAvailabilitiesOfTeacher(args: ListAvailabilitiesOfTeacherArgs, headers?: object, signal?: AbortSignal): Promise<ListAvailabilitiesOfTeacherReturn>
  cancelClass(args: CancelClassArgs, headers?: object, signal?: AbortSignal): Promise<CancelClassReturn>
}

export interface ListClassesArgs {
}

export interface ListClassesReturn {
  classes: Array<ListClass>  
}
export interface ListTeachersOfStudentArgs {
}

export interface ListTeachersOfStudentReturn {
  teachers: Array<Teacher>  
}
export interface GetHoursBankForTeacherArgs {
  teacherId: string
}

export interface GetHoursBankForTeacherReturn {
  hours: number  
}
export interface ListAvailabilitiesOfTeacherArgs {
  teacherId: string
}

export interface ListAvailabilitiesOfTeacherReturn {
  timeSlots: Array<TimeSlot>  
}
export interface CancelClassArgs {
  classId: string
}

export interface CancelClassReturn {  
}

export interface TeacherServiceAPI {
  findTeacherByID(args: FindTeacherByIDArgs, headers?: object, signal?: AbortSignal): Promise<FindTeacherByIDReturn>
  listClassesOfTeacher(args: ListClassesOfTeacherArgs, headers?: object, signal?: AbortSignal): Promise<ListClassesOfTeacherReturn>
  listStudentsOfTeacher(args: ListStudentsOfTeacherArgs, headers?: object, signal?: AbortSignal): Promise<ListStudentsOfTeacherReturn>
  findStudentOfTeacher(args: FindStudentOfTeacherArgs, headers?: object, signal?: AbortSignal): Promise<FindStudentOfTeacherReturn>
  listAvailabilities(args: ListAvailabilitiesArgs, headers?: object, signal?: AbortSignal): Promise<ListAvailabilitiesReturn>
  teach(args: TeachArgs, headers?: object, signal?: AbortSignal): Promise<TeachReturn>
  stopTeachingTopics(args: StopTeachingTopicsArgs, headers?: object, signal?: AbortSignal): Promise<StopTeachingTopicsReturn>
  addAvailability(args: AddAvailabilityArgs, headers?: object, signal?: AbortSignal): Promise<AddAvailabilityReturn>
  updateAvailability(args: UpdateAvailabilityArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAvailabilityReturn>
  deleteAvailability(args: DeleteAvailabilityArgs, headers?: object, signal?: AbortSignal): Promise<DeleteAvailabilityReturn>
  cancelClass(args: CancelClassArgs, headers?: object, signal?: AbortSignal): Promise<CancelClassReturn>
}

export interface FindTeacherByIDArgs {
  id: string
}

export interface FindTeacherByIDReturn {
  teacher: Teacher  
}
export interface ListClassesOfTeacherArgs {
  teacherId: string
}

export interface ListClassesOfTeacherReturn {
  classes: Array<Class>  
}
export interface ListStudentsOfTeacherArgs {
  teacherId: string
}

export interface ListStudentsOfTeacherReturn {
  students: Array<User>  
}
export interface FindStudentOfTeacherArgs {
  studentId: string
  teacherId: string
}

export interface FindStudentOfTeacherReturn {
  student: User  
}
export interface ListAvailabilitiesArgs {
  teacherId: string
}

export interface ListAvailabilitiesReturn {
  timeSlots: Array<TimeSlot>  
}
export interface TeachArgs {
  topic: string
}

export interface TeachReturn {  
}
export interface StopTeachingTopicsArgs {
  topics: Array<string>
}

export interface StopTeachingTopicsReturn {  
}
export interface AddAvailabilityArgs {
  req: AddAvailabilityRequest
}

export interface AddAvailabilityReturn {
  timeSlots: Array<TimeSlot>  
}
export interface UpdateAvailabilityArgs {
  req: EditAvailabilityRequest
}

export interface UpdateAvailabilityReturn {
  timeSlots: Array<TimeSlot>  
}
export interface DeleteAvailabilityArgs {
  id: string
}

export interface DeleteAvailabilityReturn {  
}
export interface CancelClassArgs {
  classId: string
}

export interface CancelClassReturn {
  usersInClass: Array<User>
  teacher: User  
}

export interface ClassServiceAPI {
  listLanguages(headers?: object, signal?: AbortSignal): Promise<ListLanguagesReturn>
  listTopics(headers?: object, signal?: AbortSignal): Promise<ListTopicsReturn>
  showClassDetails(args: ShowClassDetailsArgs, headers?: object, signal?: AbortSignal): Promise<ShowClassDetailsReturn>
}

export interface ListLanguagesArgs {
}

export interface ListLanguagesReturn {
  languages: Array<string>  
}
export interface ListTopicsArgs {
}

export interface ListTopicsReturn {
  topics: Array<string>  
}
export interface ShowClassDetailsArgs {
  classId: string
}

export interface ShowClassDetailsReturn {
  classDetails: ClassDetails  
}

export interface MessageServiceAPI {
  createOneToOneConversation(args: CreateOneToOneConversationArgs, headers?: object, signal?: AbortSignal): Promise<CreateOneToOneConversationReturn>
  sendMessageToUser(args: SendMessageToUserArgs, headers?: object, signal?: AbortSignal): Promise<SendMessageToUserReturn>
  sendMessageToClass(args: SendMessageToClassArgs, headers?: object, signal?: AbortSignal): Promise<SendMessageToClassReturn>
  findConversationById(args: FindConversationByIdArgs, headers?: object, signal?: AbortSignal): Promise<FindConversationByIdReturn>
  findOneToOneConversation(args: FindOneToOneConversationArgs, headers?: object, signal?: AbortSignal): Promise<FindOneToOneConversationReturn>
  listConversationsOfUser(args: ListConversationsOfUserArgs, headers?: object, signal?: AbortSignal): Promise<ListConversationsOfUserReturn>
  listMessagesOfConversation(args: ListMessagesOfConversationArgs, headers?: object, signal?: AbortSignal): Promise<ListMessagesOfConversationReturn>
  listMessagesOfConversationWithCursor(args: ListMessagesOfConversationWithCursorArgs, headers?: object, signal?: AbortSignal): Promise<ListMessagesOfConversationWithCursorReturn>
}

export interface CreateOneToOneConversationArgs {
  recepientId: string
}

export interface CreateOneToOneConversationReturn {
  conversationId: number  
}
export interface SendMessageToUserArgs {
  message: SentMessage
}

export interface SendMessageToUserReturn {  
}
export interface SendMessageToClassArgs {
  message: SentMessage
}

export interface SendMessageToClassReturn {  
}
export interface FindConversationByIdArgs {
  conversationId: number
}

export interface FindConversationByIdReturn {
  conversation: Conversation  
}
export interface FindOneToOneConversationArgs {
  user1Id: string
  user2Id: string
}

export interface FindOneToOneConversationReturn {
  conversation: Conversation  
}
export interface ListConversationsOfUserArgs {
  userId: string
}

export interface ListConversationsOfUserReturn {
  conversations: Array<Conversation>  
}
export interface ListMessagesOfConversationArgs {
  conversationId: number
}

export interface ListMessagesOfConversationReturn {
  messages: Array<Message>  
}
export interface ListMessagesOfConversationWithCursorArgs {
  conversationId: number
  cursor: string
}

export interface ListMessagesOfConversationWithCursorReturn {
  messages: Array<Message>
  isMore: boolean  
}

export interface SubscriptionServiceAPI {
  listSubscriptions(headers?: object, signal?: AbortSignal): Promise<ListSubscriptionsReturn>
  addSubscriptionForStudent(args: AddSubscriptionForStudentArgs, headers?: object, signal?: AbortSignal): Promise<AddSubscriptionForStudentReturn>
}

export interface ListSubscriptionsArgs {
}

export interface ListSubscriptionsReturn {
  subscriptions: Array<Subscription>  
}
export interface AddSubscriptionForStudentArgs {
  studentId: string
  teacherId: string
  subscriptionId: string
}

export interface AddSubscriptionForStudentReturn {  
}


  
//
// Client
//
export class PublicServiceAPI implements PublicServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/PublicServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  createOrJoinClass = (args: CreateOrJoinClassArgs, headers?: object, signal?: AbortSignal): Promise<CreateOrJoinClassReturn> => {
    return this.fetch(
      this.url('CreateOrJoinClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          class: <Class>(_data.class),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  addHoursToHoursBank = (args: AddHoursToHoursBankArgs, headers?: object, signal?: AbortSignal): Promise<AddHoursToHoursBankReturn> => {
    return this.fetch(
      this.url('AddHoursToHoursBank'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class UserServiceAPI implements UserServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/UserServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  get = (headers?: object, signal?: AbortSignal): Promise<GetReturn> => {
    return this.fetch(
      this.url('Get'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          user: <User>(_data.user),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  findUserByID = (args: FindUserByIDArgs, headers?: object, signal?: AbortSignal): Promise<FindUserByIDReturn> => {
    return this.fetch(
      this.url('FindUserByID'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          user: <User>(_data.user),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listTeachers = (args: ListTeachersArgs, headers?: object, signal?: AbortSignal): Promise<ListTeachersReturn> => {
    return this.fetch(
      this.url('ListTeachers'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          teachers: <Array<ListTeacher>>(_data.teachers),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  teachersCount = (headers?: object, signal?: AbortSignal): Promise<TeachersCountReturn> => {
    return this.fetch(
      this.url('TeachersCount'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          count: <number>(_data.count),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listTopicsTaught = (headers?: object, signal?: AbortSignal): Promise<ListTopicsTaughtReturn> => {
    return this.fetch(
      this.url('ListTopicsTaught'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          topics: <Array<Topic>>(_data.topics),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listLanguagesTaught = (headers?: object, signal?: AbortSignal): Promise<ListLanguagesTaughtReturn> => {
    return this.fetch(
      this.url('ListLanguagesTaught'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          languages: <Array<string>>(_data.languages),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  createStudent = (args: CreateStudentArgs, headers?: object, signal?: AbortSignal): Promise<CreateStudentReturn> => {
    return this.fetch(
      this.url('CreateStudent'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  createTeacher = (args: CreateTeacherArgs, headers?: object, signal?: AbortSignal): Promise<CreateTeacherReturn> => {
    return this.fetch(
      this.url('CreateTeacher'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  updatePreferedLanguage = (args: UpdatePreferedLanguageArgs, headers?: object, signal?: AbortSignal): Promise<UpdatePreferedLanguageReturn> => {
    return this.fetch(
      this.url('UpdatePreferedLanguage'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  updateAvatar = (args: UpdateAvatarArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAvatarReturn> => {
    return this.fetch(
      this.url('UpdateAvatar'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  deleteAvatar = (headers?: object, signal?: AbortSignal): Promise<DeleteAvatarReturn> => {
    return this.fetch(
      this.url('DeleteAvatar'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  delete = (headers?: object, signal?: AbortSignal): Promise<DeleteReturn> => {
    return this.fetch(
      this.url('Delete'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  addStripeCustomerId = (args: AddStripeCustomerIdArgs, headers?: object, signal?: AbortSignal): Promise<AddStripeCustomerIdReturn> => {
    return this.fetch(
      this.url('AddStripeCustomerId'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class StudentServiceAPI implements StudentServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/StudentServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  listClasses = (headers?: object, signal?: AbortSignal): Promise<ListClassesReturn> => {
    return this.fetch(
      this.url('ListClasses'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          classes: <Array<ListClass>>(_data.classes),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listTeachersOfStudent = (headers?: object, signal?: AbortSignal): Promise<ListTeachersOfStudentReturn> => {
    return this.fetch(
      this.url('ListTeachersOfStudent'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          teachers: <Array<Teacher>>(_data.teachers),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  getHoursBankForTeacher = (args: GetHoursBankForTeacherArgs, headers?: object, signal?: AbortSignal): Promise<GetHoursBankForTeacherReturn> => {
    return this.fetch(
      this.url('GetHoursBankForTeacher'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          hours: <number>(_data.hours),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listAvailabilitiesOfTeacher = (args: ListAvailabilitiesOfTeacherArgs, headers?: object, signal?: AbortSignal): Promise<ListAvailabilitiesOfTeacherReturn> => {
    return this.fetch(
      this.url('ListAvailabilitiesOfTeacher'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          timeSlots: <Array<TimeSlot>>(_data.timeSlots),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  cancelClass = (args: CancelClassArgs, headers?: object, signal?: AbortSignal): Promise<CancelClassReturn> => {
    return this.fetch(
      this.url('CancelClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class TeacherServiceAPI implements TeacherServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/TeacherServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  findTeacherByID = (args: FindTeacherByIDArgs, headers?: object, signal?: AbortSignal): Promise<FindTeacherByIDReturn> => {
    return this.fetch(
      this.url('FindTeacherByID'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          teacher: <Teacher>(_data.teacher),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listClassesOfTeacher = (args: ListClassesOfTeacherArgs, headers?: object, signal?: AbortSignal): Promise<ListClassesOfTeacherReturn> => {
    return this.fetch(
      this.url('ListClassesOfTeacher'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          classes: <Array<Class>>(_data.classes),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listStudentsOfTeacher = (args: ListStudentsOfTeacherArgs, headers?: object, signal?: AbortSignal): Promise<ListStudentsOfTeacherReturn> => {
    return this.fetch(
      this.url('ListStudentsOfTeacher'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          students: <Array<User>>(_data.students),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  findStudentOfTeacher = (args: FindStudentOfTeacherArgs, headers?: object, signal?: AbortSignal): Promise<FindStudentOfTeacherReturn> => {
    return this.fetch(
      this.url('FindStudentOfTeacher'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          student: <User>(_data.student),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listAvailabilities = (args: ListAvailabilitiesArgs, headers?: object, signal?: AbortSignal): Promise<ListAvailabilitiesReturn> => {
    return this.fetch(
      this.url('ListAvailabilities'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          timeSlots: <Array<TimeSlot>>(_data.timeSlots),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  teach = (args: TeachArgs, headers?: object, signal?: AbortSignal): Promise<TeachReturn> => {
    return this.fetch(
      this.url('Teach'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  stopTeachingTopics = (args: StopTeachingTopicsArgs, headers?: object, signal?: AbortSignal): Promise<StopTeachingTopicsReturn> => {
    return this.fetch(
      this.url('StopTeachingTopics'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  addAvailability = (args: AddAvailabilityArgs, headers?: object, signal?: AbortSignal): Promise<AddAvailabilityReturn> => {
    return this.fetch(
      this.url('AddAvailability'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          timeSlots: <Array<TimeSlot>>(_data.timeSlots),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  updateAvailability = (args: UpdateAvailabilityArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAvailabilityReturn> => {
    return this.fetch(
      this.url('UpdateAvailability'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          timeSlots: <Array<TimeSlot>>(_data.timeSlots),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  deleteAvailability = (args: DeleteAvailabilityArgs, headers?: object, signal?: AbortSignal): Promise<DeleteAvailabilityReturn> => {
    return this.fetch(
      this.url('DeleteAvailability'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  cancelClass = (args: CancelClassArgs, headers?: object, signal?: AbortSignal): Promise<CancelClassReturn> => {
    return this.fetch(
      this.url('CancelClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          usersInClass: <Array<User>>(_data.usersInClass),
          teacher: <User>(_data.teacher),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class ClassServiceAPI implements ClassServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/ClassServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  listLanguages = (headers?: object, signal?: AbortSignal): Promise<ListLanguagesReturn> => {
    return this.fetch(
      this.url('ListLanguages'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          languages: <Array<string>>(_data.languages),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listTopics = (headers?: object, signal?: AbortSignal): Promise<ListTopicsReturn> => {
    return this.fetch(
      this.url('ListTopics'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          topics: <Array<string>>(_data.topics),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  showClassDetails = (args: ShowClassDetailsArgs, headers?: object, signal?: AbortSignal): Promise<ShowClassDetailsReturn> => {
    return this.fetch(
      this.url('ShowClassDetails'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          classDetails: <ClassDetails>(_data.classDetails),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class MessageServiceAPI implements MessageServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/MessageServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  createOneToOneConversation = (args: CreateOneToOneConversationArgs, headers?: object, signal?: AbortSignal): Promise<CreateOneToOneConversationReturn> => {
    return this.fetch(
      this.url('CreateOneToOneConversation'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          conversationId: <number>(_data.conversationId),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  sendMessageToUser = (args: SendMessageToUserArgs, headers?: object, signal?: AbortSignal): Promise<SendMessageToUserReturn> => {
    return this.fetch(
      this.url('SendMessageToUser'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  sendMessageToClass = (args: SendMessageToClassArgs, headers?: object, signal?: AbortSignal): Promise<SendMessageToClassReturn> => {
    return this.fetch(
      this.url('SendMessageToClass'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  findConversationById = (args: FindConversationByIdArgs, headers?: object, signal?: AbortSignal): Promise<FindConversationByIdReturn> => {
    return this.fetch(
      this.url('FindConversationById'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          conversation: <Conversation>(_data.conversation),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  findOneToOneConversation = (args: FindOneToOneConversationArgs, headers?: object, signal?: AbortSignal): Promise<FindOneToOneConversationReturn> => {
    return this.fetch(
      this.url('FindOneToOneConversation'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          conversation: <Conversation>(_data.conversation),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listConversationsOfUser = (args: ListConversationsOfUserArgs, headers?: object, signal?: AbortSignal): Promise<ListConversationsOfUserReturn> => {
    return this.fetch(
      this.url('ListConversationsOfUser'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          conversations: <Array<Conversation>>(_data.conversations),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listMessagesOfConversation = (args: ListMessagesOfConversationArgs, headers?: object, signal?: AbortSignal): Promise<ListMessagesOfConversationReturn> => {
    return this.fetch(
      this.url('ListMessagesOfConversation'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          messages: <Array<Message>>(_data.messages),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  listMessagesOfConversationWithCursor = (args: ListMessagesOfConversationWithCursorArgs, headers?: object, signal?: AbortSignal): Promise<ListMessagesOfConversationWithCursorReturn> => {
    return this.fetch(
      this.url('ListMessagesOfConversationWithCursor'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          messages: <Array<Message>>(_data.messages),
          isMore: <boolean>(_data.isMore),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

export class SubscriptionServiceAPI implements SubscriptionServiceAPI {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/SubscriptionServiceAPI/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  listSubscriptions = (headers?: object, signal?: AbortSignal): Promise<ListSubscriptionsReturn> => {
    return this.fetch(
      this.url('ListSubscriptions'),
      createHTTPRequest({}, headers, signal)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          subscriptions: <Array<Subscription>>(_data.subscriptions),
        }
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
  addSubscriptionForStudent = (args: AddSubscriptionForStudentArgs, headers?: object, signal?: AbortSignal): Promise<AddSubscriptionForStudentReturn> => {
    return this.fetch(
      this.url('AddSubscriptionForStudent'),
      createHTTPRequest(args, headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return {}
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
    })
  }
  
}

  const createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {}),
    signal
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(error) {
      let message = ''
      if (error instanceof Error)  {
        message = error.message
      }
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text}`},
      )
    }
    if (!res.ok) {
      const code: number = (typeof data.code === 'number') ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

//
// Errors
//

export class WebrpcError extends Error {
  name: string
  code: number
  message: string
  status: number
  cause?: string

  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
  msg: string

  constructor(name: string, code: number, message: string, status: number, cause?: string) {
    super(message)
    this.name = name || 'WebrpcError'
    this.code = typeof code === 'number' ? code : 0
    this.message = message || `endpoint error ${this.code}`
    this.msg = this.message
    this.status = typeof status === 'number' ? status : 0
    this.cause = cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)
  }
}

// Webrpc errors

export class WebrpcEndpointError extends WebrpcError {
  constructor(
    name: string = 'WebrpcEndpoint',
    code: number = 0,
    message: string = 'endpoint error',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcRequestFailed',
    code: number = -1,
    message: string = 'request failed',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadRoute',
    code: number = -2,
    message: string = 'bad route',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadMethod',
    code: number = -3,
    message: string = 'bad method',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadRequest',
    code: number = -4,
    message: string = 'bad request',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadResponse',
    code: number = -5,
    message: string = 'bad response',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(
    name: string = 'WebrpcServerPanic',
    code: number = -6,
    message: string = 'server panic',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(
    name: string = 'WebrpcInternalError',
    code: number = -7,
    message: string = 'internal error',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}


// Schema errors

export class UnauthorizedError extends WebrpcError {
  constructor(
    name: string = 'Unauthorized',
    code: number = 401,
    message: string = 'Unauthorized access',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(
    name: string = 'PermissionDenied',
    code: number = 403,
    message: string = 'Permission denied',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class NotFoundError extends WebrpcError {
  constructor(
    name: string = 'NotFound',
    code: number = 404,
    message: string = 'Not found',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, NotFoundError.prototype)
  }
}

export class UserAlreadyRegisteredError extends WebrpcError {
  constructor(
    name: string = 'UserAlreadyRegistered',
    code: number = 1,
    message: string = 'User already registered',
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UserAlreadyRegisteredError.prototype)
  }
}


export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  NotFound = 'NotFound',
  UserAlreadyRegistered = 'UserAlreadyRegistered',
}

const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [401]: UnauthorizedError,
  [403]: PermissionDeniedError,
  [404]: NotFoundError,
  [1]: UserAlreadyRegisteredError,
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
